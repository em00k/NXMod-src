
; --------------------------------------------------------------------------


;*******************************************************
;*  ----- protracker v2.3f replay routine (cia) -----  *
;*******************************************************
;
; This replayer has been slightly optimized over the pt2.3d replayer,
; but it's still far from fully optimized. It has also been rewritten to
; behave like pt2.3f's internal replayer, for maximum accuracy.
;
; changelog:
; - 04.10.2021: fixed crucial bug in mt_init. thanks to insane/rabenauge^tscc!
; - 05.10.2021: fixed lut bug in arpeggio routine. thanks again to insane!
;
; - 04.11.2021: 1) rewritten again to match pt2.3f's internal replayer
;               2) removed mulus/divus, as part of optimizing
;               3) dword alignment, as part of optimizing
;               4) long cmp+beq chains replaced with jump tables
;               5) fixed tremolo effect & sample-num + volume slide
;               6) set back old led status on exit
;               7) set default bpm on mt_init
;               8) clear more replayer variables on mt_init
;
; CIA version:
; Call setciaint to install the interrupt server. then call mt_init
; to initialize the song. playback starts when the mt_enable flag
; is set to a non-zero value. to end the song and turn off all voices,
; call mt_end. at last, call resetciaint to remove the interrupt.
;
; This replay routine is modified to work exactly like the tracker replayer,
; thus it is accurate, but not optimized in any way.
;
; You can use this routine to play a module. just remove the semicolons.
; also change the module path in mt_data at the very bottom of this file.
; exit by pressing both mouse buttons.


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; Notes for Amiga Paula registers.


; AUDXVOL set on TICK 0  mt_getnewnote     if new note
; AUDXVOL set on TICK 0  mt_checkeffects   if no note and pattern delay
; AUDXVOL set on TICK N  mt_checkeffects   always


; AUDXPER is set on TICK 0 is previous row was NULL.


; (0 tick only)    (N any except 0)    (D pattern delayed so all ticks)

;	 TICK

;             AUDXPER      0  N  D

; mt_arpeggio	/  /  /		; 0xy (arpeggio)
; mt_portaup	/  /  /		; 1xx (portamento up)
; mt_portadown	/  /  /		; 2xx (portamento down)
; mt_toneportamento	/  /  /		; 3xx (tone portamento)
; mt_vibrato	/  /  /		; 4xy (vibrato)
; mt_toneplusvolslide	/  /  /		; 5xy (tone portamento + vol slide)
; mt_vibratoplusvolslide	/  /  /		; 6xy (vibrato + volume slide)
; setback	/  /  /		; 7 - not used here
; setback	/  /  /		; 8 - unused!
; setback	   /  /		; 9 - not used here
; setback	/  /  /		; a - not used here
; setback	   /  /		; b - not used here
; setback	   /  /		; c - not used here
; setback	   /  /		; d - not used here
; mt_e_commands	    		; exy (extended commands)
; setback	   /  /		; f - not used here

; mt_pernop	/     /		; 0 - not used
; mt_pernop	/     /		; 1 - not used
; mt_pernop	/     /		; 2 - not used
; mt_pernop	/     /		; 3 - not used
; mt_pernop	/     /		; 4 - not used
; mt_pernop	/     /		; 5 - not used
; mt_pernop	/     /		; 6 - not used
; mt_pernop	/     /		; 7 - not used
; mt_pernop	/     /		; 8 - not used
; mt_sampleoffset	       		; 9xx (set sample offset)
; mt_pernop	/     /		; a - not used
; mt_positionjump	       		; bxx (position jump)
; mt_volumechange	       		; cxx (set volume)
; mt_patternbreak	       		; dxx (pattern break)
; mt_setspeed	       		; fxx (set speed)

; mt_filteronoff	    		; e0x (set led filter)
; mt_fineportaup	/     /		; e1x (fine portamento up)
; mt_fineportadown	/     /		; e2x (fine portamento down)
; mt_setglisscontrol	    		; e3x (glissando/funk control)
; mt_setvibratocontrol	    		; e4x (vibrato control)
; mt_setfinetune	    		; e5x (set finetune)
; mt_jumploop	    		; e6x (pattern loop)
; mt_settremolocontrol	    		; e7x (tremolo control)
; mt_karplusstrong	    		; e8x (karplus-strong)
; mt_retrignote	   /		; e9x (retrig note)
; mt_volumefineup	    		; eax (fine volume-slide up)
; mt_volumefinedown	    		; ebx (fine volume-slide down)
; mt_notecut	    		; ecx (note cut)
; mt_notedelay	   /		; edx (note delay)
; mt_patterndelay	    		; eex (pattern delay)
; mt_funkit	    		; efx (invert loop)


; Conclusion for ZX Spectrum Next engine.


; AUDXPER should *ONLY* be set by note trigger and commands that modify it.


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


;	TICK

; mt_arpeggio	-N	; 0xy (arpeggio)
; mt_portaup	-N	; 1xx (portamento up)
; mt_portadown	-N	; 2xx (portamento down)
; mt_toneportamento	-N	; 3xx (tone portamento)
; mt_vibrato	0N	; 4xy (vibrato)
; mt_toneplusvolslide	-N	; 5xy (tone portamento + vol slide)
; mt_vibratoplusvolslide	-N	; 6xy (vibrato + vol slide)
; mt_tremolo	0N	; 7xy (tremolo)
; mt_return3	--	; 8-- NOT USED
; mt_sampleoffset	0-	; 9xx (set sample offset)
; mt_volumeslide	-N	; axy (volume slide)
; mt_positionjump	0-	; bxx (position jump)
; mt_volumechange	0-	; cxx (set volume)
; mt_patternbreak	0-	; dxx (pattern break)
; mt_e_commands	0N	; exy (extended commands)
; mt_setspeed	0-	; fxx (set speed)

; mt_return3     	--	; e0- NOT USED
; mt_fineportaup	0-	; e1x (fine portamento up)
; mt_fineportadown	0-	; e2x (fine portamento down)
; mt_setglisscontrol	0-	; e3x (glissando control)
; mt_setvibratocontrol	0-	; e4x (vibrato control)
; mt_setfinetune	0-	; e5x (set finetune)
; mt_jumploop	0-	; e6x (pattern loop)
; mt_settremolocontrol	0-	; e7x (tremolo control)
; mt_return3	--	; e8- NOT USED
; mt_retrignote	-N	; e9x (retrig note)
; mt_volumefineup	0-	; eax (fine volume slide up)
; mt_volumefinedown	0-	; ebx (fine volume slide down)
; mt_notecut	-N	; ecx (note cut)
; mt_notedelay	-N	; edx (note delay)
; mt_patterndelay	0-	; eex (pattern delay)
; mt_return3	--	; ef- NOT USED


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; Test loop.


main:	bsr.w	setciaint	; CIA timer init
	bsr.w	mt_init

	st	mt_enable	; PLAY mode

	move.l	4.w,a6
	lea	dosname(pc),a1
	moveq	#0,d0
	jsr	lvoopenlibrary(a6)

	tst.l	d0
	beq.b	theend

	move.l	d0,a6

wloop:	moveq	#10,d1
	jsr	lvodelay(a6)
	btst	#6,$bfe001
	bne.b	wloop

	btst	#2,$dff016
	bne.b	wloop

	move.l	a6,a1
	move.l	4.w,a6
	jsr	lvocloselibrary(a6)

theend:	bsr.w	mt_end		; Stop player and Paula DMA

	bsr.w	resetciaint	; CIA timer reset
	rts


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; Start CIA interrupt (uses either A or B).


addicrvector	=   -6
remicrvector	=  -12
lvoopenresource	= -498
lvoopenlibrary	= -552
lvocloselibrary	= -414
lvodelay	= -198

ciatalo	= $400
ciatahi	= $500
ciatblo	= $600
ciatbhi	= $700
ciacra	= $e00
ciacrb	= $f00


setciaint:	moveq	#2,d6
	lea	$bfd000,a5
	move.b	#'b',ciaaname+3

setcialoop:	moveq	#0,d0
	lea	ciaaname(pc),a1
	move.l	4.w,a6
	jsr	lvoopenresource(a6)
	move.l	d0,ciaabase
	beq.w	mt_return3

	lea	gfxname(pc),a1
	moveq	#0,d0
	jsr	lvoopenlibrary(a6)
	tst.l	d0
	beq	resetciaint
	move.l	d0,a1
	move.w	206(a1),d0		; displayflags
	btst	#2,d0			; Region?
	beq.b	wasntsc
	move.l	#1773447,d7 		;  PAL 0.709379
	bra.b	sciask

wasntsc:	move.l	#1789773,d7 		; NTSC 0.715909

sciask:	move.l	d7,timervalue
	divu	#125,d7 		; Default to normal 50 hz timer
	jsr	lvocloselibrary(a6)

	move.l	ciaabase(pc),a6
	cmp.w	#2,d6
	beq.b	trytimera

trytimerb:	lea	musicintserver(pc),a1
	moveq	#1,d0			; bit 1: timer b
	jsr	addicrvector(a6)
	move.l	#1,timerflag
	tst.l	d0
	bne.b	ciaerror
	move.l	a5,ciaaaddr
	move.b	d7,ciatblo(a5)
	lsr.w	#8,d7
	move.b	d7,ciatbhi(a5)
	bset	#0,ciacrb(a5)
	rts

trytimera:	lea	musicintserver(pc),a1
	moveq	#0,d0			; bit 0: timer a
	jsr	addicrvector(a6)
	clr.l	timerflag
	tst.l	d0
	bne.b	ciaerror
	move.l	a5,ciaaaddr
	move.b	d7,ciatalo(a5)
	lsr.w	#8,d7
	move.b	d7,ciatahi(a5)
	bset	#0,ciacra(a5)
	rts

ciaerror:	move.b	#'a',ciaaname+3
	lea	$bfe001,a5
	subq.w	#1,d6
	bne	setcialoop
	clr.l	ciaabase
	rts

resetciaint:	move.l	ciaabase(pc),d0
	beq.w	mt_return3
	clr.l	ciaabase
	move.l	d0,a6
	move.l	ciaaaddr(pc),a5
	tst.l	timerflag
	beq.b	restimera

	bclr	#0,ciacrb(a5)
	moveq	#1,d0
	bra.b	remint

restimera:	bclr	#0,ciacra(a5)
	moveq	#0,d0

remint:	lea	musicintserver(pc),a1
	moveq	#0,d0
	jsr	remicrvector(a6)
	rts


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; Set CIA timer for BPM tempo rate.


; CIA counts down at 1/10 of CPU clock;


; ProTracker uses a **MAGIC** number for each system (NTSC/PAL);


; VIDEO   MAGIC   BPM   RESULT      CIA      COUNT         TEMPO
; --------------------------------------------------------------
;  NTSC 1789773 / 125 = 14318.184 : 715909 / 14318 = 50.00062858
;   PAL 1773447 / 125 = 14187.576 : 709379 / 14187 = 50.00204412

;  NTSC 125 = 125.0050751 due to 16-bit CIA resolution (DIVU).
;   PAL 125 = 125.0016064 due to 16-bit CIA resolution (DIVU).


;  32 BPM runs CIA timer @ 12.8Hz

; 125 BPM runs CIA timer @   50Hz (matches SPEED of 6)
; 250 BPM runs CIA timer @  100Hz


; > D0 = Tempo 0..255


settempo:	move.l	ciaabase(pc),d2
	beq.w	mt_return3		; No CIA?

	cmp.w	#32,d0
	bhs.b	setemsk			; HIGHER OR SAME
	moveq	#32,d0			; Clamp to 32 BPM

setemsk:	move.w	d0,realtempo		; Current tempo
	move.l	timervalue(pc),d2

	divu	d0,d2	; D2 = 1773447 PAL : 1789773 NTSC

	move.l	ciaaaddr(pc),a4		; D2 = clock/bpm
	move.l	timerflag(pc),d0	; D0 = CIA A or B
	beq.b	settema

	move.b	d2,ciatblo(a4)		; CIA rate = result
	lsr.w	#8,d2
	move.b	d2,ciatbhi(a4)
	rts

settema:	move.b	d2,ciatalo(a4)		; CIA rate = result
	lsr.w	#8,d2
	move.b	d2,ciatahi(a4)
	rts


; --------------------------------------------------------------------------


; Interrupt variables.


	cnop	0,4

ciaaaddr	dc.l	0
ciaabase	dc.l	0

timerflag	dc.l	0	; Tempo (bpm 32..255)
timervalue	dc.l	0	; NTSC/PAL clock

realtempo	dc.w	125	; Copy of current bpm set in settempo

ledstatus	dc.b	0


; --------------------------------------------------------------------------


; CIA vector and OS data.


	cnop	0,4

musicintserver	dc.l	0,0
	dc.b	2,5 		; type, priority
	dc.l	musintname
	dc.l	0,mt_intmusic	; MOD player

dosname	dc.b	"dos.library",0
ciaaname	dc.b	"ciaa.resource",0
gfxname	dc.b	"graphics.library",0
musintname	dc.b	"ProTracker interrupt",0
	even


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; Channel structure (see mt_audchan1temp)


n_note	equ	0  ; w (must be first!)
n_cmd	equ	2  ; w (must be second!)
n_cmdlo	equ	3  ; b (offset in n_cmd)
n_start	equ	4  ; l AUDxLCH (aligned)
n_loopstart	equ	8  ; l
n_wavestart	equ	12 ; l
n_peroffset	equ	16 ; l (offset to finetuned period-lut section)
n_length	equ	20 ; w AUDxLEN (aligned)
n_replen	equ	22 ; w AUDxLEN
n_period	equ	24 ; w AUDxPER
n_dmabit	equ	26 ; w DMACON
n_wantedperiod	equ	28 ; w
n_finetune	equ	30 ; b
n_volume	equ	31 ; b AUDxVOL
n_toneportdirec	equ	32 ; b
n_toneportspeed	equ	33 ; b 0 INIT ?
n_vibratocmd	equ	34 ; b
n_vibratopos	equ	35 ; b
n_tremolocmd	equ	36 ; b
n_tremolopos	equ	37 ; b
n_wavecontrol	equ	38 ; b
n_glissfunk	equ	39 ; b
n_sampleoffset	equ	40 ; b
n_pattpos	equ	41 ; b
n_loopcount	equ	42 ; b
n_funkoffset	equ	43 ; b


; --------------------------------------------------------------------------


; Paula hardware register offsets.


;AUDxLCH	equ	0	; DWORD location (high/low)
;AUDxLCL	equ	2	;
;AUDxLEN	equ	4	; WORD  length
;AUDxPER	equ	6	; WORD  period
;AUDxVOL	equ	8	; WORD  volume


; --------------------------------------------------------------------------


; Initialize player using MOD data.


mt_init:	lea	mt_data,a0
	move.l	a0,mt_songdataptr
	
	; count number of patterns (find highest referred pattern)

	lea	952(a0),a1	; order list address
	moveq	#128-1,d0	; 128 order list entries
	moveq	#0,d1

mtloop:	move.l	d1,d2
	subq.w	#1,d0

mtloop2:	move.b	(a1)+,d1
	cmp.b	d2,d1
	bgt.b	mtloop		; SIGNED
	dbra	d0,mtloop2
	addq.b	#1,d2
	
	; generate mt_samplestarts list and fix samples

	lea	mt_samplestarts(pc),a1
	
	lsl.l	#8,d2
	lsl.l	#2,d2		; d2 *= 1024 
	add.l	#1084,d2
	add.l	a0,d2
	move.l	d2,a2		; a2 is now the address of first sample's data
	moveq	#31-1,d0	; handle 31 samples

mtloop3:	move.w  48(a0),d3	; get replen
	tst.w   d3		; replen is zero?
	bne.b   mtskip		; no
	move.w  #1,48(a0)	; yes, set to 1 (fixes lock-up)

mtskip:	cmp.w   #1,d3		; loop enabled?
	bhi.b   mtskip2		; HIGHER
	clr.w   (a2)		; no, clear first two bytes of sample

mtskip2:	move.l	a2,(a1)+	; move sample address into mt_samplestarts slot
	moveq	#0,d1
	move.w	42(a0),d1 	; get sample length
	add.l	d1,d1		; turn into real sample length
	add.l	d1,a2		; add to address
	lea	30(a0),a0	; skip to next sample list entry
	dbra	d0,mtloop3

	; initialize stuff

	move.b	$bfe001,d0	; copy of led filter state
	and.b	#2,d0
	move.b	d0,ledstatus
	bset	#1,$bfe001	; turn off led filter

	; --------------------

	move.b	#6,mt_speed	; Default 6 tick compare

	clr.b	mt_counter	; TICK counter  = 0
	clr.b	mt_songpos	; Song position = 0
	clr.w	mt_patternpos	;  ROW position = 0
	clr.b	mt_pattdelaytime
	clr.b	mt_pattdelaytime2
	bsr.w	mt_restoreeffects

	moveq	#125,d0		; Init timer with default
	bsr.w	settempo

	sf	mt_enable	; PLAY mode

	bra.b	mt_turnoffvoices; Mute Paula 


; --------------------------------------------------------------------------


; Shut everything down.


mt_end:	sf	mt_enable	; STOP mode

	bclr	#1,$bfe001	; Restore previous led filter state
	move.b	ledstatus(pc),d0
	or.b	d0,$bfe001

mt_turnoffvoices:	lea	$dff000,a0	; **HARDWARE**

	move.w	#$000f,$96(a0)	; Trn off voice DMAs
	moveq	#0,d0		; Clear voice volumes
	move.w	d0,$a8(a0)			
	move.w	d0,$b8(a0)
	move.w	d0,$c8(a0)
	move.w	d0,$d8(a0)
	rts


; --------------------------------------------------------------------------


; Reset effect variables to 0.


mt_restoreeffects:	lea	mt_audchan1temp(pc),a0
	bsr.b	reefsub
	lea	mt_audchan2temp(pc),a0
	bsr.b	reefsub
	lea	mt_audchan3temp(pc),a0
	bsr.b	reefsub
	lea	mt_audchan4temp(pc),a0

reefsub:	clr.b	n_wavecontrol(a0)
	clr.b	n_glissfunk(a0)
	clr.b	n_finetune(a0)
	clr.b	n_loopcount(a0)
	rts


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------

; --------------------------------------------------------------------------


; CIA interrupt routine (play MOD).


mt_intmusic:	movem.l	d0-d7/a0-a6,-(sp)
	tst.b	mt_enable	    ; PLAY mode?
	beq.w	mt_exit

	addq.b	#1,mt_counter	    ; TICK++
	move.b	mt_counter(pc),d0
	cmp.b	mt_speed(pc),d0	    ; TICK < SPEED 0..31 ?
	blo.b	mt_nonewnote	    ; LOWER

	clr.b	mt_counter	    ; Now on TICK 0

	tst.b	mt_pattdelaytime2   ; Delayed?
	beq.b	mt_getnewnote	    ; Play NOTE if 0 delay

	bsr.b	mt_nonewallchannels ; Run TICK N effects

	bra.w	mt_dskip	    ; Pattern pos hack


; Only run effects and song position.


mt_nonewnote:	bsr.b	mt_nonewallchannels ; Ef, 0,1,2,3,4,5,6
	bra.w	mt_nonewpositionyet ; Song position check


; Run effects for each channel then set volume.


; Order: EF, 0,1,2,3,4,5,6,7,A,E, VOL


mt_nonewallchannels:	lea	mt_audchan1temp(pc),a6
	lea	$dff0a0,a5		; AUD0LCH
	bsr.w	mt_checkeffects

	lea	mt_audchan2temp(pc),a6
	lea	$dff0b0,a5		; AUD1LCH
	bsr.w	mt_checkeffects

	lea	mt_audchan3temp(pc),a6
	lea	$dff0c0,a5		; AUD2LCH
	bsr.w	mt_checkeffects

	lea	mt_audchan4temp(pc),a6
	lea	$dff0d0,a5		; AUD3LCH
	bra.w	mt_checkeffects


; Play sample for each channel.


; Order: NOTE, 3,5,9,B,C,D,E,F, VOL


mt_getnewnote:	move.l	mt_songdataptr(pc),a0
	lea	12(a0),a3
	lea	952(a0),a2	;pattpo
	lea	1084(a0),a0	;patterndata

	moveq	#0,d0
	move.b	mt_songpos(pc),d0
	moveq	#0,d1
	move.b	(a2,d0.w),d1

	swap	d1
	lsr.l	#6,d1 ; d1 *= 1024 (faster than 8+2 shift on 68000)
	
	add.w	mt_patternpos(pc),d1
	clr.w	mt_dmacontemp

	lea	$dff0a0,a5		; AUD0LCH
	lea	mt_audchan1temp(pc),a6
	bsr.b	mt_playvoice
	moveq	#0,d0
	move.b	n_volume(a6),d0
	move.w	d0,8(a5)		; AUD0VOL
	
	lea	$dff0b0,a5		; AUD1LCH
	lea	mt_audchan2temp(pc),a6
	bsr.b	mt_playvoice
	moveq	#0,d0
	move.b	n_volume(a6),d0
	move.w	d0,8(a5)		; AUD1VOL
	
	lea	$dff0c0,a5		; AUD2LCH
	lea	mt_audchan3temp(pc),a6
	bsr.b	mt_playvoice
	moveq	#0,d0
	move.b	n_volume(a6),d0
	move.w	d0,8(a5)		; AUD2VOL
	
	lea	$dff0d0,a5		; AUD3LCH
	lea	mt_audchan4temp(pc),a6
	bsr.b	mt_playvoice
	moveq	#0,d0
	move.b	n_volume(a6),d0
	move.w	d0,8(a5)		; AUD3VOL

	bra.w	mt_setdma

;	------------
;	------------
;	------------
;	------------
;	------------
;	------------
;	------------


; Exits branching to mt_checkmoreeffects


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_playvoice:	tst.l	(a6)
	bne.b	mt_plvskip
	bsr.w	mt_pernop

;	------------

mt_plvskip:	move.l	(a0,d1.l),(a6)	; Read note from pattern
	addq.l	#4,d1
	moveq	#0,d2
	move.b	n_cmd(a6),d2	; Get lower 4 bits of instrument
	and.b	#$f0,d2
	lsr.b	#4,d2
	move.b	(a6),d0		; Get higher 4 bits of instrument
	and.b	#$f0,d0
	or.b	d0,d2
	tst.b	d2
	beq.w	mt_setregisters	; Instrument was zero

	moveq	#0,d3
	lea	mt_samplestarts(pc),a1
	move	d2,d4
	subq.l	#1,d2
	lsl.l	#2,d2
	mulu.w	#30,d4
	move.l	(a1,d2.l),n_start(a6)
	move.w	(a3,d4.l),n_length(a6)

	moveq	#0,d0
	move.b	2(a3,d4.l),d0
	and.b	#$0f,d0
	move.b	d0,n_finetune(a6)

	; ----------------------------------

	lsl.b	#2,d0 ; update n_peroffset
	lea	mt_ftunepertab(pc),a4
	move.l	(a4,d0.w),n_peroffset(a6)

	; ----------------------------------
	
	move.b	3(a3,d4.l),n_volume(a6)
	move.w	4(a3,d4.l),d3		; Get repeat
	tst.w	d3
	beq.b	mt_noloop

	move.l	n_start(a6),d2		; Get start
	add.l	d3,d3
	add.l	d3,d2			; Add repeat
	move.l	d2,n_loopstart(a6)
	move.l	d2,n_wavestart(a6)
	move.w	4(a3,d4.l),d0		; Get repeat
	add.w	6(a3,d4.l),d0		; Add replen
	move.w	d0,n_length(a6)
	move.w	6(a3,d4.l),n_replen(a6)	; Save replen
	bra.b	mt_setregisters

;	------------

mt_noloop:	move.l	n_start(a6),d2
	add.l	d3,d2
	move.l	d2,n_loopstart(a6)
	move.l	d2,n_wavestart(a6)
	move.w	6(a3,d4.l),n_replen(a6)	; Save replen

;	------------

mt_setregisters:	move.w	(a6),d0
	and.w	#$0fff,d0
	beq.w	mt_checkmoreeffects ; Exit if no note

	move.w	2(a6),d0
	and.w	#$ff0,d0
	cmp.w	#$e50,d0		; Finetune
	beq.b	mt_dosetfinetune

	move.b	2(a6),d0 ; Special cases for some effects
	and.b	#$0f,d0

	cmp.b	#3,d0			; Toneportamento
	beq.b	mt_chktoneporta

	cmp.b	#5,d0		; Toneportamento + volslide
	beq.b	mt_chktoneporta

	cmp.b	#9,d0			; Sample offset
	bne.b	mt_setperiod

	bsr.w	mt_checkmoreeffects ; Call CMD 9xx
	bra.b	mt_setperiod

mt_dosetfinetune:	bsr.w	mt_setfinetune
	bra.b	mt_setperiod

mt_chktoneporta:	bsr.w	mt_settoneporta		; Calls mt_pernop
	bra.w	mt_checkmoreeffects ; Bypass mt_setperiod

;	------------
;	------------
;	------------

mt_setperiod:	movem.l	d1/a0/a1,-(sp)
	move.w	(a6),d1
	and.w	#$0fff,d1
	lea	mt_periodtable(pc),a1
	moveq	#0,d0
	moveq	#$24,d7

mt_ftuloop:	cmp.w	(a1,d0.w),d1
	bhs.b	mt_ftufound		; HIGHER OR SAME
	addq.w	#2,d0
	dbra	d7,mt_ftuloop

mt_ftufound:	move.l	n_peroffset(a6),a1
	move.w	(a1,d0.w),n_period(a6)
	movem.l	(sp)+,d1/a0/a1

	move.w	2(a6),d0
	and.w	#$0ff0,d0
	cmp.w	#$0ed0,d0 		; Notedelay
	beq.w	mt_checkmoreeffects	; **DMA DELAY**

;	------------

	move.w	n_dmabit(a6),$dff096	; DMACON (CLR bit)

	btst	#2,n_wavecontrol(a6)	; **DMA TRIGGER**
	bne.b	mt_vibnoc
	clr.b	n_vibratopos(a6)

mt_vibnoc:	btst	#6,n_wavecontrol(a6)
	bne.b	mt_trenoc
	clr.b	n_tremolopos(a6)

mt_trenoc:	move.w	n_length(a6),4(a5)	; AUDxLEN
	move.l	n_start(a6),(a5)	; AUDxLCH
	bne.b   mt_sdmaskp
	clr.l	n_loopstart(a6)
	moveq	#1,d0
	move.w	d0,4(a5)		; AUDxLEN
	move.w	d0,n_replen(a6)

mt_sdmaskp:	move.w	n_period(a6),d0
	move.w	d0,6(a5)		; AUDxPER
	move.w	n_dmabit(a6),d0
	or.w	d0,mt_dmacontemp
	bra.w	mt_checkmoreeffects

;	------------
;	------------
;	------------

mt_setdma:	move.l	a0,-(sp)	; Set Paula registers
	move.l	d1,-(sp)
	
	; scanline-wait (wait before starting Paula DMA)

	lea	$dff006,a0		; **HARDWARE**
	moveq	#7-1,d1

lineloop1:	move.b	(a0),d0

waiteol1:	cmp.b	(a0),d0
	beq.b	waiteol1
	dbra	d1,lineloop1

	move.w	mt_dmacontemp(pc),d0
	or.w	#$8000,d0
	move.w	d0,$dff096		; DMACON (SET bit)
	
	; scanline-wait (wait for Paula DMA to latch)

	moveq	#7-1,d1

lineloop2:	move.b	(a0),d0

waiteol2:	cmp.b	(a0),d0
	beq.b	waiteol2
	dbra	d1,lineloop2
	move.l	(sp)+,d1
	move.l	(sp)+,a0

	lea	$dff000,a5		; **HARDWARE**

	lea	mt_audchan4temp(pc),a6
	move.l	n_loopstart(a6),$d0(a5)	; AUD3LCH
	move.w	n_replen(a6),$d4(a5)	; AUD3LEN

	lea	mt_audchan3temp(pc),a6
	move.l	n_loopstart(a6),$c0(a5)	; AUD2LCH
	move.w	n_replen(a6),$c4(a5)	; AUD2LEN

	lea	mt_audchan2temp(pc),a6
	move.l	n_loopstart(a6),$b0(a5)	; AUD1LCH
	move.w	n_replen(a6),$b4(a5)	; AUD1LEN

	lea	mt_audchan1temp(pc),a6
	move.l	n_loopstart(a6),$a0(a5)	; AUD0LCH
	move.w	n_replen(a6),$a4(a5)	; AUD0LEN

;	------------
;	------------
;	------------

mt_dskip:	add.w	#16,mt_patternpos
	move.b	mt_pattdelaytime(pc),d0
	beq.b	mt_dskpc
	move.b	d0,mt_pattdelaytime2
	clr.b	mt_pattdelaytime

mt_dskpc:	tst.b	mt_pattdelaytime2
	beq.b	mt_dskpa
	subq.b	#1,mt_pattdelaytime2
	beq.b	mt_dskpa
	sub.w	#16,mt_patternpos

mt_dskpa:	tst.b	mt_pbreakflag
	beq.b	mt_nnpysk
	sf	mt_pbreakflag
	moveq	#0,d0
	move.b	mt_pbreakpos(pc),d0
	lsl.w	#4,d0
	move.w	d0,mt_patternpos
	clr.b	mt_pbreakpos

mt_nnpysk:	cmp.w	#1024,mt_patternpos	; End of pattern?
	blo.b	mt_nonewpositionyet	; LOWER

;	------------

mt_nextposition:	moveq	#0,d0
	move.b	mt_pbreakpos(pc),d0
	lsl.w	#4,d0
	move.w	d0,mt_patternpos

	clr.b	mt_pbreakpos
	clr.b	mt_posjumpflag		; Clear jump flag

	addq.b	#1,mt_songpos
	and.b	#$7f,mt_songpos
	move.b	mt_songpos(pc),d1
	move.l	mt_songdataptr(pc),a0
	cmp.b	950(a0),d1
	blo.b	mt_nonewpositionyet	; LOWER
	clr.b	mt_songpos
	
mt_nonewpositionyet:	tst.b	mt_posjumpflag
	bne.b	mt_nextposition

mt_exit:	movem.l	(sp)+,d0-d7/a0-a6
	rts


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; Process effects EF, 0,1,2,3,4,5,6,7,A,E and set volume.


; mt_tremolo adjusts the stack to bypass the volume register write.


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)

	
mt_checkeffects:	bsr.b	mt_chkefx2	; **SP HACK** mt_tremolo

	moveq	#0,d0		; D0 = volume 0..64
	move.b	n_volume(a6),d0

	move.w	d0,8(a5)		; AUDxVOL
	rts


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------

	
; TICK N effect list (NOT called on TICK 0 when mt_pattdelaytime2 = 0)


; These effects are not called if there is a new note on TICK 0.

; The pattern delay logic bypasses these effects during a 'new note' event.

; setback routine updates the audio period register and checks 7xy and Axy.


	cnop 0,4

mt_jumplist1	dc.l	mt_arpeggio		; 0xy (arpeggio)
	dc.l	mt_portaup		; 1xx (portamento up)
	dc.l	mt_portadown		; 2xx (portamento down)
	dc.l	mt_toneportamento	; 3xx (tone portamento)
	dc.l	mt_vibrato		; 4xy (vibrato)
	dc.l	mt_toneplusvolslide	; 5xy (tone portamento + volume slide)
	dc.l	mt_vibratoplusvolslide	; 6xy (vibrato + volume slide)
	dc.l	setback			; 7 - not used here
	dc.l	setback			; 8 - unused!
	dc.l	setback			; 9 - not used here
	dc.l	setback			; a - not used here
	dc.l	setback			; b - not used here
	dc.l	setback			; c - not used here
	dc.l	setback			; d - not used here
	dc.l	mt_e_commands		; exy (extended commands)
	dc.l	setback			; f - not used here


; --------------------------------------------------------------------------


; Process effects Ef, 0,1,2,3,4,5,6,7,A,E


mt_chkefx2:	bsr.w	mt_updatefunk

	move.w	n_cmd(a6),d0
	and.w	#$0fff,d0
	beq.b	mt_return3

	moveq	#0,d0
	move.b	n_cmd(a6),d0
	and.b	#$0f,d0

	move.w	d0,d1
	lsl.b	#2,d1

	move.l	mt_jumplist1(pc,d1.w),a4
	jmp	(a4) ; every efx has rts at the end, this is safe


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; Set period, check tremolo (7) and volume slide (A)


; > D0 = Command


setback:	move.w	n_period(a6),6(a5)	; AUDxPER

	cmp.b	#7,d0
	beq.w	mt_tremolo

	cmp.b	#$a,d0
	beq.w	mt_volumeslide

mt_return3:	rts


; --------------------------------------------------------------------------


mt_pernop:	move.w	n_period(a6),6(a5)	; AUDxPER
	rts
	

; --------------------------------------------------------------------------


	; div -> lut optimization. divu is 140+ cycles on a 68000.


mt_arptab	dc.b	0,1,2,0,1,2,0,1
	dc.b	2,0,1,2,0,1,2,0
	dc.b	1,2,0,1,2,0,1,2
	dc.b	0,1,2,0,1,2,0,1


; --------------------------------------------------------------------------


; CMD $0xy


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_arpeggio:	moveq	#0,d0
	move.b	mt_counter(pc),d0
	and.b	#$1f,d0			; just in case
	move.b	mt_arptab(pc,d0.w),d0
	cmp.b	#1,d0
	beq.b	mt_arpeggio1
	cmp.b	#2,d0
	beq.b	mt_arpeggio2

mt_arpeggio0:	move.w	n_period(a6),d2
	bra.b	mt_arpeggioset
	
mt_arpeggio1:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	lsr.b	#4,d0
	bra.b	mt_arpeggiofind

mt_arpeggio2:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#15,d0

mt_arpeggiofind:	add.w	d0,d0
	move.l	n_peroffset(a6),a0
	moveq	#0,d1
	move.w	n_period(a6),d1
	moveq	#$24,d3

mt_arploop:	move.w	(a0,d0.w),d2
	cmp.w	(a0),d1
	bhs.b	mt_arpeggioset		; HIGHER OR SAME
	addq.l	#2,a0
	dbra	d3,mt_arploop
	rts

mt_arpeggioset:	move.w	d2,6(a5)		; AUDxPER
	rts


; --------------------------------------------------------------------------


; CMD $E1


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_fineportaup:	tst.b	mt_counter
	bne.w	mt_return3
	move.b	#$0f,mt_lowmask


; --------------------------------------------------------------------------


; CMD $1xx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_portaup:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	mt_lowmask(pc),d0
	move.b	#$ff,mt_lowmask
	sub.w	d0,n_period(a6)
	move.w	n_period(a6),d0
	and.w	#$0fff,d0
	cmp.w	#$0071,d0
	bpl.b	mt_portauskip		; POSITIVE
	and.w	#$f000,n_period(a6)
	or.w	#$0071,n_period(a6)

mt_portauskip:	move.w	n_period(a6),d0
	and.w	#$0fff,d0
	move.w	d0,6(a5)		; AUDxPER
	rts	


; --------------------------------------------------------------------------


; CMD $E2


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)

 
mt_fineportadown:	tst.b	mt_counter
	bne.w	mt_return3
	move.b	#$0f,mt_lowmask


; --------------------------------------------------------------------------


; CMD $2xx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_portadown:	clr.w	d0
	move.b	n_cmdlo(a6),d0
	and.b	mt_lowmask(pc),d0
	move.b	#$ff,mt_lowmask
	add.w	d0,n_period(a6)
	move.w	n_period(a6),d0
	and.w	#$0fff,d0
	cmp.w	#$0358,d0
	bmi.b	mt_portadskip		; NEGATIVE
	and.w	#$f000,n_period(a6)
	or.w	#$0358,n_period(a6)

mt_portadskip:	move.w	n_period(a6),d0
	and.w	#$0fff,d0
	move.w	d0,6(a5)		; AUDxPER
	rts


; --------------------------------------------------------------------------


; > A6 = Audio channel x temp (see n_note)


mt_settoneporta:	move.w	(a6),d2
	and.w	#$0fff,d2
	move.l	n_peroffset(a6),a4
	moveq	#0,d0

mt_stploop:	cmp.w	(a4,d0.w),d2
	bhs.b	mt_stpfound		; HIGHER OR SAME
	addq.w	#2,d0
	cmp.w	#37*2,d0
	blo.b	mt_stploop		; LOWER
	moveq	#35*2,d0

mt_stpfound:	move.b	n_finetune(a6),d2
	and.b	#8,d2
	beq.b	mt_stpgoss
	tst.w	d0
	beq.b	mt_stpgoss
	subq.w	#2,d0

mt_stpgoss:	move.w	(a4,d0.w),d2
	move.w	d2,n_wantedperiod(a6)
	move.w	n_period(a6),d0
	clr.b	n_toneportdirec(a6)
	cmp.w	d0,d2
	beq.b	mt_cleartoneporta
	bge.w	mt_return3		; SIGNED
	move.b	#1,n_toneportdirec(a6)
	rts

mt_cleartoneporta:	clr.w	n_wantedperiod(a6)
	rts


; --------------------------------------------------------------------------


; CMD $3xx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_toneportamento:	move.b	n_cmdlo(a6),d0
	beq.b	mt_toneportnochange
	move.b	d0,n_toneportspeed(a6)
	clr.b	n_cmdlo(a6)

mt_toneportnochange:	tst.w	n_wantedperiod(a6)
	beq.w	mt_return3
	moveq	#0,d0
	move.b	n_toneportspeed(a6),d0
	tst.b	n_toneportdirec(a6)
	bne.b	mt_toneportaup

mt_toneportadown:	add.w	d0,n_period(a6)
	move.w	n_wantedperiod(a6),d0
	cmp.w	n_period(a6),d0
	bgt.b	mt_toneportasetper		; SIGNED
	move.w	n_wantedperiod(a6),n_period(a6)
	clr.w	n_wantedperiod(a6)
	bra.b	mt_toneportasetper

mt_toneportaup:	sub.w	d0,n_period(a6)
	move.w	n_wantedperiod(a6),d0
	cmp.w	n_period(a6),d0
	blt.b	mt_toneportasetper		; SIGNED
	move.w	n_wantedperiod(a6),n_period(a6)
	clr.w	n_wantedperiod(a6)

mt_toneportasetper:	move.w	n_period(a6),d2
	move.b	n_glissfunk(a6),d0
	and.b	#$0f,d0
	beq.b	mt_glissskip
	move.l	n_peroffset(a6),a0	
	moveq	#0,d0

mt_glissloop:	cmp.w	(a0,d0.w),d2
	bhs.b	mt_glissfound		; HIGHER OR SAME
	addq.w	#2,d0
	cmp.w	#37*2,d0
	blo.b	mt_glissloop		; LOWER
	moveq	#35*2,d0

mt_glissfound:	move.w	(a0,d0.w),d2

mt_glissskip:	move.w	d2,6(a5)		; AUDxPER
	rts


; --------------------------------------------------------------------------


; CMD $4xy


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_vibrato:	move.b	n_cmdlo(a6),d0
	beq.b	mt_vibrato2
	move.b	n_vibratocmd(a6),d2
	and.b	#$0f,d0
	beq.b	mt_vibskip
	and.b	#$f0,d2
	or.b	d0,d2

mt_vibskip:	move.b	n_cmdlo(a6),d0
	and.b	#$f0,d0
	beq.b	mt_vibskip2
	and.b	#$0f,d2
	or.b	d0,d2

mt_vibskip2:	move.b	d2,n_vibratocmd(a6)

mt_vibrato2:	move.b	n_vibratopos(a6),d0
	lea	mt_vibratotable(pc),a4
	lsr.w	#2,d0
	and.w	#$001f,d0
	moveq	#0,d2
	move.b	n_wavecontrol(a6),d2
	and.b	#3,d2
	beq.b	mt_vib_sine
	lsl.b	#3,d0
	cmp.b	#1,d2
	beq.b	mt_vib_rampdown
	move.b	#255,d2
	bra.b	mt_vib_set

mt_vib_rampdown:	tst.b	n_vibratopos(a6)
	bpl.b	mt_vib_rampdown2	; POSITIVE
	move.b	#255,d2
	sub.b	d0,d2
	bra.b	mt_vib_set

mt_vib_rampdown2:	move.b	d0,d2
	bra.b	mt_vib_set

mt_vib_sine:	move.b	(a4,d0.w),d2

mt_vib_set:	move.b	n_vibratocmd(a6),d0
	and.w	#15,d0
	mulu.w	d0,d2
	lsr.w	#7,d2
	move.w	n_period(a6),d0
	tst.b	n_vibratopos(a6)
	bmi.b	mt_vibratoneg		; NEGATIVE
	add.w	d2,d0
	bra.b	mt_vibrato3

mt_vibratoneg:	sub.w	d2,d0

mt_vibrato3:	move.w	d0,6(a5)		; AUDxPER
	move.b	n_vibratocmd(a6),d0
	lsr.w	#2,d0
	and.w	#$003c,d0
	add.b	d0,n_vibratopos(a6)
	rts


; --------------------------------------------------------------------------


; CMD $5xy


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_toneplusvolslide:	bsr.w	mt_toneportnochange
	bra.w	mt_volumeslide


; --------------------------------------------------------------------------


; CMD $6xy


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_vibratoplusvolslide:	bsr.b	mt_vibrato2
	bra.w	mt_volumeslide


; --------------------------------------------------------------------------


; CMD $7xy


; > A6 = Audio channel x temp (see n_note)


mt_tremolo:	move.b	n_cmdlo(a6),d0
	beq.b	mt_tremolo2
	move.b	n_tremolocmd(a6),d2
	and.b	#$0f,d0
	beq.b	mt_treskip
	and.b	#$f0,d2
	or.b	d0,d2

mt_treskip:	move.b	n_cmdlo(a6),d0
	and.b	#$f0,d0
	beq.b	mt_treskip2
	and.b	#$0f,d2
	or.b	d0,d2

mt_treskip2:	move.b	d2,n_tremolocmd(a6)

mt_tremolo2:	move.b	n_tremolopos(a6),d0
	lea	mt_vibratotable(pc),a4
	lsr.w	#2,d0
	and.w	#$001f,d0
	moveq	#0,d2
	move.b	n_wavecontrol(a6),d2
	lsr.b	#4,d2
	and.b	#3,d2
	beq.b	mt_tre_sine
	lsl.b	#3,d0
	cmp.b	#1,d2
	beq.b	mt_tre_rampdown
	move.b	#255,d2
	bra.b	mt_tre_set

mt_tre_rampdown:	tst.b	n_vibratopos(a6)
	bpl.b	mt_tre_rampdown2	; POSITIVE
	move.b	#255,d2
	sub.b	d0,d2
	bra.b	mt_tre_set

mt_tre_rampdown2:	move.b	d0,d2
	bra.b	mt_tre_set

mt_tre_sine:	move.b	(a4,d0.w),d2

mt_tre_set:	move.b	n_tremolocmd(a6),d0
	and.w	#15,d0
	mulu.w	d0,d2
	lsr.w	#6,d2
	moveq	#0,d0
	move.b	n_volume(a6),d0
	tst.b	n_tremolopos(a6)
	bmi.b	mt_tremoloneg		; NEGATIVE
	add.w	d2,d0
	bra.b	mt_tremolo3

mt_tremoloneg:	sub.w	d2,d0

mt_tremolo3:	bpl.b	mt_tremoloskip		; POSITIVE
	clr.w	d0

mt_tremoloskip:	cmp.w	#$40,d0
	bls.b	mt_tremolook		; LOWER OR SAME
	move.w	#$40,d0

mt_tremolook:	move.w	d0,8(a5)		; AUDxVOL
	move.b	n_tremolocmd(a6),d0
	lsr.w	#2,d0
	and.w	#$003c,d0
	add.b	d0,n_tremolopos(a6)

	addq.l	#4,sp		; hack to not set volume
	rts			; in mt_checkeffects


; --------------------------------------------------------------------------


; CMD $9xx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_sampleoffset:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	beq.b	mt_sononew
	move.b	d0,n_sampleoffset(a6)

mt_sononew:	move.b	n_sampleoffset(a6),d0
	lsl.w	#7,d0
	cmp.w	n_length(a6),d0
	bge.b	mt_sofskip		; SIGNED
	sub.w	d0,n_length(a6)
	add.w	d0,d0
	add.l	d0,n_start(a6)
	rts

mt_sofskip:	move.w	#$0001,n_length(a6)
	rts


; --------------------------------------------------------------------------


; CMD $Axy


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_volumeslide:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	lsr.b	#4,d0
	tst.b	d0
	beq.b	mt_volslidedown

mt_volslideup:	add.b	d0,n_volume(a6)
	cmp.b	#$40,n_volume(a6)
	bmi.b	mt_vsuskip		; NEGATIVE
	move.b	#$40,n_volume(a6)
mt_vsuskip:	rts

mt_volslidedown:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0

mt_volslidedown2:	sub.b	d0,n_volume(a6)
	bpl.b	mt_vsdskip		; POSITIVE
	clr.b	n_volume(a6)
mt_vsdskip:	rts


; --------------------------------------------------------------------------


; CMD $Bxx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_positionjump:	move.b	n_cmdlo(a6),d0
	subq.b	#1,d0
	move.b	d0,mt_songpos

mt_pj2:	clr.b	mt_pbreakpos
	st 	mt_posjumpflag
	rts


; --------------------------------------------------------------------------


; CMD $Cxx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_volumechange:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	cmp.b	#$40,d0
	bls.b	mt_volumeok		; LOWER OR SAME
	moveq	#$40,d0

mt_volumeok:	move.b	d0,n_volume(a6)
	rts


; --------------------------------------------------------------------------


; CMD $Dxx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_patternbreak:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	move.l	d0,d2
	lsr.b	#4,d0
	mulu.w	#10,d0
	and.b	#$0f,d2
	add.b	d2,d0
	cmp.b	#63,d0
	bhi.b	mt_pj2			; HIGHER
	move.b	d0,mt_pbreakpos
	st	mt_posjumpflag
	rts


; --------------------------------------------------------------------------


; CMD $Fxx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_setspeed:	moveq	#0,d0		; Clear 32-bits of D0

	move.b	3(a6),d0	; 3 = BYTE4 (xx)
	beq.w	mt_end		; STOP? (speed = 0)

	cmp.b	#32,d0		; BPM?
	bhs.w	settempo	; HIGHER OR SAME

	clr.b	mt_counter	; Reset TICK
	move.b	d0,mt_speed	; Set new speed
	rts
	

; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; TICK 0 effect list (ONLY called when mt_pattdelaytime2 = 0)

; These effects are called when there is a 'new note' on TICK 0.

; The pattern delay counter is used to bypass 'new note' TICK 0
; events so uses mt_jumplist1 instead.

; mt_pernop routine updates the audio period register.


	cnop 0,4

mt_jumplist2	dc.l	mt_pernop	; 0 - not used
	dc.l	mt_pernop	; 1 - not used
	dc.l	mt_pernop	; 2 - not used
	dc.l	mt_pernop	; 3 - not used
	dc.l	mt_pernop	; 4 - not used
	dc.l	mt_pernop	; 5 - not used
	dc.l	mt_pernop	; 6 - not used
	dc.l	mt_pernop	; 7 - not used
	dc.l	mt_pernop	; 8 - not used
	dc.l	mt_sampleoffset	; 9xx (set sample offset)
	dc.l	mt_pernop	; a - not used
	dc.l	mt_positionjump	; bxx (position jump)
	dc.l	mt_volumechange	; cxx (set volume)
	dc.l	mt_patternbreak	; dxx (pattern break)
	dc.l	mt_e_commands	; exy (extended commands)
	dc.l	mt_setspeed	; fxx (set speed)


; --------------------------------------------------------------------------


; Process effects 9,B,C,D,E,F on TICK 0

		
mt_checkmoreeffects:	moveq	#0,d0
	move.b	2(a6),d0
	and.b	#$0f,d0
	lsl.b	#2,d0

	move.l	mt_jumplist2(pc,d0.w),a4
	jmp	(a4) ; every efx has rts at the end, this is safe
	

; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; TICK N effect list (ALWAYS called on all ticks).

; mt_counter is used to bypass some of these effects if not TICK 0;

; tst.b  mt_counter
; bne.w  mt_return3

; ld     a,(mt_counter)
; and    a
; ret    nz


	cnop 0,4

mt_e_jumplist	dc.l	mt_filteronoff		; e0x (set led filter)
	dc.l	mt_fineportaup		; e1x (fine portamento up)
	dc.l	mt_fineportadown	; e2x (fine portamento down)
	dc.l	mt_setglisscontrol	; e3x (glissando/funk control)
	dc.l	mt_setvibratocontrol	; e4x (vibrato control)
	dc.l	mt_setfinetune		; e5x (set finetune)
	dc.l	mt_jumploop		; e6x (pattern loop)
	dc.l	mt_settremolocontrol	; e7x (tremolo control)
	dc.l	mt_karplusstrong	; e8x (karplus-strong)
	dc.l	mt_retrignote		; e9x (retrig note)
	dc.l	mt_volumefineup		; eax (fine volume-slide up)
	dc.l	mt_volumefinedown	; ebx (fine volume-slide down)
	dc.l	mt_notecut		; ecx (note cut)
	dc.l	mt_notedelay		; edx (note delay)
	dc.l	mt_patterndelay		; eex (pattern delay)
	dc.l	mt_funkit		; efx (invert loop)


; --------------------------------------------------------------------------


; CMD $Exy


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_e_commands:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$f0,d0
	lsr.b	#4-2,d0
	move.l	mt_e_jumplist(pc,d0.w),a4
	jmp	(a4) ; every e-efx has rts at the end, this is safe


; --------------------------------------------------------------------------
; --------------------------------------------------------------------------
; --------------------------------------------------------------------------


; CMD $E0x


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_filteronoff:	move.b	n_cmdlo(a6),d0
	and.b	#1,d0
	add.b	d0,d0
	and.b	#$fd,$bfe001
	or.b	d0,$bfe001
	rts	


; --------------------------------------------------------------------------


; CMD $E3x


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_setglisscontrol:	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	and.b	#$f0,n_glissfunk(a6)
	or.b	d0,n_glissfunk(a6)
	rts


; --------------------------------------------------------------------------


; CMD $E4x


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_setvibratocontrol:	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	and.b	#$f0,n_wavecontrol(a6)
	or.b	d0,n_wavecontrol(a6)
	rts


; --------------------------------------------------------------------------


; CMD $E5x


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_setfinetune:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	move.b	d0,n_finetune(a6)

	; ----------------------------------
	lsl.b	#2,d0	; update n_peroffset
	lea	mt_ftunepertab(pc),a4
	move.l	(a4,d0.w),n_peroffset(a6)
	; ----------------------------------
	rts


; --------------------------------------------------------------------------


; CMD $E6x


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_jumploop:	tst.b	mt_counter
	bne.w	mt_return3

	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	beq.b	mt_setloop
	tst.b	n_loopcount(a6)
	beq.b	mt_jumpcnt
	subq.b	#1,n_loopcount(a6)
	beq.w	mt_return3

mt_jmploop:	move.b	n_pattpos(a6),mt_pbreakpos
	st	mt_pbreakflag
	rts

mt_jumpcnt:	move.b	d0,n_loopcount(a6)
	bra.b	mt_jmploop

mt_setloop:	move.w	mt_patternpos(pc),d0
	lsr.w	#4,d0
	and.b	#63,d0
	move.b	d0,n_pattpos(a6)
	rts


; --------------------------------------------------------------------------


; CMD $E7x


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_settremolocontrol:	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	lsl.b	#4,d0
	and.b	#$0f,n_wavecontrol(a6)
	or.b	d0,n_wavecontrol(a6)
	rts


; --------------------------------------------------------------------------


; CMD $E8x


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_karplusstrong:	movem.l	d1/d2/a0/a1,-(sp)
	move.l	n_loopstart(a6),a0
	cmp.w	#0,a0
	beq.b	karplend
	move.l	a0,a1
	move.w	n_replen(a6),d0
	add.w	d0,d0
	subq.w	#2,d0

karplop:	move.b	(a0),d1
	ext.w	d1
	move.b	1(a0),d2
	ext.w	d2
	add.w	d1,d2
	asr.w	#1,d2
	move.b	d2,(a0)+
	dbra	d0,karplop
	move.b	(a0),d1
	ext.w	d1
	move.b	(a1),d2
	ext.w	d2
	add.w	d1,d2
	asr.w	#1,d2
	move.b	d2,(a0)

karplend:	movem.l	(sp)+,d1/d2/a0/a1
	rts


; --------------------------------------------------------------------------


; CMD $E9x


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_retrignote:	move.l	d1,-(sp)
	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	beq.b	mt_rtnend
	moveq	#0,d1
	move.b	mt_counter(pc),d1
	bne.b	mt_rtnskp
	move.w	n_note(a6),d1
	and.w	#$0fff,d1
	bne.b	mt_rtnend
	moveq	#0,d1
	move.b	mt_counter(pc),d1

mt_rtnskp:	and.b	#$1f,d1	; just in case
	lsl.w	#5,d0
	add.w	d0,d1
	move.b	mt_retrigtab(pc,d1.w),d0
	bne.b	mt_rtnend

;	------------

mt_doretrig:	move.w	n_dmabit(a6),$dff096	; DMACON (CLR bit)
	move.l	n_start(a6),(a5)	; AUDxLCH
	move.w	n_length(a6),4(a5)	; AUDxLEN
	move.w	n_period(a6),6(a5)  	; AUDxPER

	; scanline-wait (wait before starting Paula DMA)

	move.l	a0,-(sp)
	lea	$dff006,a0
	moveq	#7-1,d1

lineloop3:	move.b	(a0),d0

waiteol3:	cmp.b	(a0),d0
	beq.b	waiteol3
	dbra	d1,lineloop3

	move.w	n_dmabit(a6),d0
	bset	#15,d0
	move.w	d0,$dff096		; DMACON (SET bit)

	; scanline-wait (wait for Paula DMA to latch)

	moveq	#7-1,d1

lineloop4:	move.b	(a0),d0

waiteol4:	cmp.b	(a0),d0
	beq.b	waiteol4
	dbra	d1,lineloop4
	move.l	(sp)+,a0

	move.l	n_loopstart(a6),(a5)	; AUDxLCH
	move.l	n_replen(a6),4(a5)	; AUDxLEN

mt_rtnend:	move.l	(sp)+,d1
	rts
	

; --------------------------------------------------------------------------


; div -> LUT optimization. maybe a bit extreme, but divu is 140+
; cycles on a 68000.


mt_retrigtab	dc.b 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	dc.b 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	dc.b 0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1
	dc.b 0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1
	dc.b 0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1
	dc.b 0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1
	dc.b 0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1
	dc.b 0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1
	dc.b 0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1
	dc.b 0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1
	dc.b 0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1
	dc.b 0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1
	dc.b 0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1
	dc.b 0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1
	dc.b 0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1
	dc.b 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1


; --------------------------------------------------------------------------


; CMD $EAx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_volumefineup:	tst.b	mt_counter
	bne.w	mt_return3
	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$f,d0
	bra.w	mt_volslideup


; --------------------------------------------------------------------------


; CMD $EBx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_volumefinedown:	tst.b	mt_counter
	bne.w	mt_return3
	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	bra.w	mt_volslidedown2


; --------------------------------------------------------------------------


; CMD $ECx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_notecut:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	cmp.b	mt_counter(pc),d0
	bne.w	mt_return3
	clr.b	n_volume(a6)
	rts


; --------------------------------------------------------------------------


; CMD $EDx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_notedelay:	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	cmp.b	mt_counter,d0
	bne.w	mt_return3
	move.w	(a6),d0
	and.w	#$0fff,d0
	beq.w	mt_return3
	move.l	d1,-(sp)		; Stack adjust
	bra.w	mt_doretrig


; --------------------------------------------------------------------------


; CMD $EEx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_patterndelay:	tst.b	mt_counter
	bne.w	mt_return3
	moveq	#0,d0
	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	tst.b	mt_pattdelaytime2
	bne.w	mt_return3

	addq.b	#1,d0
	move.b	d0,mt_pattdelaytime
	rts


; --------------------------------------------------------------------------


; CMD $EFx


; > A5 = AUDxLCH
; > A6 = Audio channel x temp (see n_note)


mt_funkit:	tst.b	mt_counter
	bne.w	mt_return3
	move.b	n_cmdlo(a6),d0
	and.b	#$0f,d0
	lsl.b	#4,d0
	and.b	#$0f,n_glissfunk(a6)
	or.b	d0,n_glissfunk(a6)
	tst.b	d0
	beq.w	mt_return3

mt_updatefunk:	move.l	d1,-(sp)
	move.l	a0,-(sp)
	moveq	#0,d0
	move.b	n_glissfunk(a6),d0
	lsr.b	#4,d0
	beq.b	mt_funkend
	lea	mt_funktable(pc),a0
	move.b	(a0,d0.w),d0
	add.b	d0,n_funkoffset(a6)
	btst	#7,n_funkoffset(a6)
	beq.b	mt_funkend
	clr.b	n_funkoffset(a6)
	move.l	n_wavestart(a6),a0
	cmp.l	#0,a0
	beq.b	mt_funkend
	move.l	n_loopstart(a6),d0
	moveq	#0,d1
	move.w	n_replen(a6),d1
	add.l	d1,d0
	add.l	d1,d0
	addq.l	#1,a0
	cmp.l	d0,a0
	blo.b	mt_funkok		; LOWER
	move.l	n_loopstart(a6),a0

mt_funkok:	move.l	a0,n_wavestart(a6)
	moveq	#-1,d0
	sub.b	(a0),d0
	move.b	d0,(a0)

mt_funkend:	move.l	(sp)+,a0
	move.l	(sp)+,d1
	rts


; --------------------------------------------------------------------------


mt_funktable	dc.b	0,5,6,7,8,10,11,13,16,19,22,26,32,43,64,128


; --------------------------------------------------------------------------


mt_vibratotable	dc.b  	  0, 24, 49, 74, 97,120,141,161
	dc.b	180,197,212,224,235,244,250,253
	dc.b	255,253,250,244,235,224,212,197
	dc.b	180,161,141,120, 97, 74, 49, 24


; --------------------------------------------------------------------------

	
; This LUT prevents mulu for getting correct period section


	cnop	0,4

mt_ftunepertab	dc.l	mt_ftune0,mt_ftune1,mt_ftune2,mt_ftune3
	dc.l	mt_ftune4,mt_ftune5,mt_ftune6,mt_ftune7
	dc.l	mt_ftune8,mt_ftune9,mt_ftunea,mt_ftuneb
	dc.l	mt_ftunec,mt_ftuned,mt_ftunee,mt_ftunef


; --------------------------------------------------------------------------


mt_periodtable


; tuning 0, normal (hardcoded to NTSC)
; tuning 1
; tuning 2
; tuning 3
; tuning 4
; tuning 5
; tuning 6
; tuning 7
; tuning -8
; tuning -7
; tuning -6
; tuning -5
; tuning -4
; tuning -3
; tuning -2
; tuning -1


mt_ftune0  dc.w   856,808,762,720,678,640,604,570,538,508,480,453
           dc.w   428,404,381,360,339,320,302,285,269,254,240,226
           dc.w   214,202,190,180,170,160,151,143,135,127,120,113,0

mt_ftune1  dc.w   850,802,757,715,674,637,601,567,535,505,477,450
           dc.w   425,401,379,357,337,318,300,284,268,253,239,225
           dc.w   213,201,189,179,169,159,150,142,134,126,119,113,0

mt_ftune2  dc.w   844,796,752,709,670,632,597,563,532,502,474,447
           dc.w   422,398,376,355,335,316,298,282,266,251,237,224
           dc.w   211,199,188,177,167,158,149,141,133,125,118,112,0

mt_ftune3  dc.w   838,791,746,704,665,628,592,559,528,498,470,444
           dc.w   419,395,373,352,332,314,296,280,264,249,235,222
           dc.w   209,198,187,176,166,157,148,140,132,125,118,111,0

mt_ftune4  dc.w   832,785,741,699,660,623,588,555,524,495,467,441
           dc.w   416,392,370,350,330,312,294,278,262,247,233,220
           dc.w   208,196,185,175,165,156,147,139,131,124,117,110,0

mt_ftune5  dc.w   826,779,736,694,655,619,584,551,520,491,463,437
           dc.w   413,390,368,347,328,309,292,276,260,245,232,219
           dc.w   206,195,184,174,164,155,146,138,130,123,116,109,0

mt_ftune6  dc.w   820,774,730,689,651,614,580,547,516,487,460,434
           dc.w   410,387,365,345,325,307,290,274,258,244,230,217
           dc.w   205,193,183,172,163,154,145,137,129,122,115,109,0

mt_ftune7  dc.w   814,768,725,684,646,610,575,543,513,484,457,431
           dc.w   407,384,363,342,323,305,288,272,256,242,228,216
           dc.w   204,192,181,171,161,152,144,136,128,121,114,108,0

mt_ftune8  dc.w   907,856,808,762,720,678,640,604,570,538,508,480
           dc.w   453,428,404,381,360,339,320,302,285,269,254,240
           dc.w   226,214,202,190,180,170,160,151,143,135,127,120,0

mt_ftune9  dc.w   900,850,802,757,715,675,636,601,567,535,505,477
           dc.w   450,425,401,379,357,337,318,300,284,268,253,238
           dc.w   225,212,200,189,179,169,159,150,142,134,126,119,0

mt_ftunea  dc.w   894,844,796,752,709,670,632,597,563,532,502,474
           dc.w   447,422,398,376,355,335,316,298,282,266,251,237
           dc.w   223,211,199,188,177,167,158,149,141,133,125,118,0

mt_ftuneb  dc.w   887,838,791,746,704,665,628,592,559,528,498,470
           dc.w   444,419,395,373,352,332,314,296,280,264,249,235
           dc.w   222,209,198,187,176,166,157,148,140,132,125,118,0

mt_ftunec  dc.w   881,832,785,741,699,660,623,588,555,524,494,467
           dc.w   441,416,392,370,350,330,312,294,278,262,247,233
           dc.w   220,208,196,185,175,165,156,147,139,131,123,117,0

mt_ftuned  dc.w   875,826,779,736,694,655,619,584,551,520,491,463
           dc.w   437,413,390,368,347,328,309,292,276,260,245,232
           dc.w   219,206,195,184,174,164,155,146,138,130,123,116,0

mt_ftunee  dc.w   868,820,774,730,689,651,614,580,547,516,487,460
           dc.w   434,410,387,365,345,325,307,290,274,258,244,230
           dc.w   217,205,193,183,172,163,154,145,137,129,122,115,0

mt_ftunef  dc.w   862,814,768,725,684,646,610,575,543,513,484,457
           dc.w   431,407,384,363,342,323,305,288,272,256,242,228
           dc.w   216,203,192,181,171,161,152,144,136,128,121,114,0


; --------------------------------------------------------------------------


; Channel structures (see n_note) (44 BYTES)


	cnop 0,4

mt_audchan1temp	dcb.b	26
	dc.w	$0001	; Voice #1 DMA bit (AUD0EN)
	dcb.b	16

	cnop	0,4

mt_audchan2temp	dcb.b	26
	dc.w	$0002	; Voice #2 DMA bit (AUD1EN)
	dcb.b	16

	cnop	0,4

mt_audchan3temp	dcb.b	26
	dc.w	$0004	; Voice #3 DMA bit (AUD2EN)
	dcb.b	16

	cnop	0,4

mt_audchan4temp	dcb.b	26
	dc.w	$0008	; Voice #4 DMA bit (AUD3EN)
	dcb.b	16


; --------------------------------------------------------------------------


; Sample start addresses.


	cnop	0,4
mt_samplestarts
	dc.l	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	dc.l	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0


; --------------------------------------------------------------------------


mt_songdataptr	dc.l	0		; MOD base address
mt_patternpos	dc.w	0		; ROW/DIVISION (BYTES)

mt_dmacontemp	dc.w	0

mt_speed	dc.b	6		; 0..31
mt_counter	dc.b	0		; TICK
mt_songpos	dc.b	0

mt_pbreakpos	dc.b	0
mt_posjumpflag	dc.b	0
mt_pbreakflag	dc.b	0

mt_lowmask	dc.b	0

mt_pattdelaytime	dc.b	0		; CMD $EE delay
mt_pattdelaytime2	dc.b	0

mt_enable	dc.b	0		; Play flag (0 STOP)


; --------------------------------------------------------------------------


	section	music,data_c

	cnop	0,4

mt_data	incbin "music.mod"


; --------------------------------------------------------------------------

